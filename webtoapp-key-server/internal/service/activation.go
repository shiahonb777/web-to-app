package service
package service

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/yingcaihuang/webtoapp-key-server/internal/domain"
	"gorm.io/gorm"
)






























































































































































































































































































}	return n	}		return -n	if n < 0 {func abs(n int64) int64 {// 绝对值函数}	return s.db.Create(log).Error		}		AppVersion:   func() string { if v, ok := req.DeviceInfo["app_version"].(string); ok { return v }; return "" }(),		ErrorMessage: errorMsg,		Result:       result,		DeviceID:     req.DeviceID,		ActivationID: func() *uint64 { if activationID > 0 { return &activationID } ; return nil }(),		Action:       "verify",	log := &domain.AuditLog{func (s *ActivationService) recordAuditLog(req *domain.VerificationRequest, activationID uint64, result, errorMsg string) error {// 记录审计日志}	return s.db.Model(activation).Update("status", status).Errorfunc (s *ActivationService) updateActivationStatus(activation *domain.ActivationKey, status string) error {// 更新激活码状态}	return int(count), nil		Count(&count)		Model(&domain.DeviceRecord{}).	s.db.Where("activation_id = ?", activationID).	var count int64func (s *ActivationService) getDeviceCount(activationID uint64) (int, error) {// 获取设备数量}	}).Error		"last_activated_at": &now,		"activation_count": device.ActivationCount + 1,	return s.db.Model(&device).Updates(map[string]interface{}{	now := time.Now()	// 更新现有设备		}		return s.db.Create(&device).Error		}			device.DeviceName = deviceInfo		if deviceInfo, ok := req.DeviceInfo["model"].(string); ok {		}			ActivationID: &activation.ID,			AppID:        req.AppID,			DeviceID:     req.DeviceID,		device = domain.DeviceRecord{		// 新设备	if result.Error == gorm.ErrRecordNotFound {		result := s.db.Where("device_id = ? AND app_id = ?", req.DeviceID, req.AppID).First(&device)		var device domain.DeviceRecordfunc (s *ActivationService) recordDevice(activation *domain.ActivationKey, req *domain.VerificationRequest) error {// 记录设备}	return hex.EncodeToString(h.Sum(nil))	h.Write([]byte(data))	h := hmac.New(sha256.New, []byte(secret))	// 使用 HMAC-SHA256		data := fmt.Sprintf("%v%v%d", resp.Success, resp.Data, resp.Timestamp)	// 拼接签名数据func (s *ActivationService) generateSignature(resp *domain.VerificationResponse, secret string) string {// 生成签名}	)		hashStr[12:16],		hashStr[8:12],		hashStr[4:8],		hashStr[0:4],	return fmt.Sprintf("%s-%s-%s-%s",	hashStr := hex.EncodeToString(hash[:])[:16]	// 取前 16 个字符，分组为 XXXX-XXXX-XXXX-XXXX	hash := sha256.Sum256(u[:])	u := uuid.New()	// 生成 UUID 的 Hashfunc generateActivationCode() string {// 生成激活码}	return strings.ToUpper(strings.ReplaceAll(code, "-", ""))func normalizeCode(code string) string {// 辅助函数：标准化激活码}		}).Error			"status": "revoked",		Updates(map[string]interface{}{		Where("id = ?", id).	return s.db.Model(&domain.ActivationKey{}).func (s *ActivationService) RevokeCode(id uint64, reason string) error {// 撤销激活码}	return items, total, nil	}		return nil, 0, err	if err := query.Offset(offset).Limit(req.Limit).Find(&items).Error; err != nil {	offset := (req.Page - 1) * req.Limit	// 分页查询	query.Model(&domain.ActivationKey{}).Count(&total)	// 计算总数	}		query = query.Where("status = ?", req.Status)	if req.Status != "" {	query := s.db.Where("app_id = ?", req.AppID)	var total int64	var items []domain.ActivationKeyfunc (s *ActivationService) ListActivationCodes(req *domain.ListRequest) ([]domain.ActivationKey, int64, error) {// 获取激活码列表}	return codes, nil	}		s.db.Create(activation)		}			CreatedBy:   "system",			Notes:       req.Notes,			DeviceLimit: req.DeviceLimit,			MaxUses:     req.MaxUses,			ExpiresAt:   expiresAt,			Status:      "active",			AppID:       req.AppID,			Code:        code,		activation := &domain.ActivationKey{		// 保存到数据库		codes[i] = code		code := generateActivationCode()	for i := 0; i < req.Count; i++ {	}		expiresAt = &expTime		expTime := time.Now().AddDate(0, 0, *req.ExpiresInDays)	if req.ExpiresInDays != nil && *req.ExpiresInDays > 0 {	var expiresAt *time.Time	codes := make([]string, req.Count)func (s *ActivationService) GenerateActivationCodes(req *domain.GenerateRequest) ([]string, error) {// 生成激活码}	return resp, nil	s.recordAuditLog(req, activation.ID, "success", "")	resp.Signature = s.generateSignature(resp, signatureSecret)	// 生成签名	}		},			CreatedAt:     activation.CreatedAt.Unix() * 1000,			RemainingUses: remainingUses,			DevicesUsed:   devicesUsed,			DeviceLimit:   activation.DeviceLimit,			ExpiresAt:     &expiresAtUnix,			ActivationID:  activation.ID,		Data: &domain.ActivationData{		Timestamp: now,		Message:   "激活成功",		Success:   true,	resp := &domain.VerificationResponse{	}		remainingUses = activation.MaxUses - activation.UsedCount - 1	if activation.MaxUses > 0 {	remainingUses := 0	devicesUsed, _ := s.getDeviceCount(activation.ID)	}		expiresAtUnix = activation.ExpiresAt.Unix() * 1000	if activation.ExpiresAt != nil {	expiresAtUnix := int64(0)	// 准备响应数据	s.recordDevice(&activation, req)	// 记录设备	})		"used_at":    &now_time,		"used_count": activation.UsedCount + 1,	s.db.Model(&activation).Updates(map[string]interface{}{	now_time := time.Now()	// 更新使用记录	}		}			}, nil				Timestamp: now,				Message:   "该激活码已达到设备激活上限",				Code:      "DEVICE_LIMIT_EXCEEDED",				Success:   false,			return &domain.VerificationResponse{			s.recordAuditLog(req, activation.ID, "failed", "设备激活数超限")		if deviceCount >= *activation.DeviceLimit {		deviceCount, _ := s.getDeviceCount(activation.ID)	if activation.DeviceLimit != nil {	// 检查设备限制	}		}, nil			Timestamp: now,			Message:   "激活码使用次数已满",			Code:      "MAX_USES_EXCEEDED",			Success:   false,		return &domain.VerificationResponse{		s.recordAuditLog(req, activation.ID, "failed", "激活码使用次数已满")		s.updateActivationStatus(&activation, "used")	if activation.MaxUses > 0 && activation.UsedCount >= activation.MaxUses {	// 检查使用次数	}		}, nil			Timestamp: now,			Message:   "激活码已过期",			Code:      "CODE_EXPIRED",			Success:   false,		return &domain.VerificationResponse{		s.recordAuditLog(req, activation.ID, "failed", "激活码已过期")		s.updateActivationStatus(&activation, "expired")	if activation.ExpiresAt != nil && time.Now().After(*activation.ExpiresAt) {	// 检查过期时间	}		}, nil			Timestamp: now,			Message:   fmt.Sprintf("激活码已%s", activation.Status),			Code:      "CODE_INACTIVE",			Success:   false,		return &domain.VerificationResponse{		s.recordAuditLog(req, activation.ID, "failed", fmt.Sprintf("激活码状态异常: %s", activation.Status))	if activation.Status != "active" {	// 检查激活码状态	}		}, nil			Timestamp: now,			Message:   "激活码不存在或已过期",			Code:      "INVALID_CODE",			Success:   false,		return &domain.VerificationResponse{		s.recordAuditLog(req, 0, "failed", "激活码不存在")	if result.Error == gorm.ErrRecordNotFound {		result := s.db.Where("code = ? AND app_id = ?", normalizeCode(req.Code), req.AppID).First(&activation)	var activation domain.ActivationKey	// 查询激活码	}		}, nil			Timestamp: now,			Message:   "请求已过期",			Code:      "TIMESTAMP_INVALID",			Success:   false,		return &domain.VerificationResponse{	if abs(now-req.Timestamp) > 300 { // 5 分钟容差	now := time.Now().Unix()	// 检查时间戳（防重放）func (s *ActivationService) VerifyCode(req *domain.VerificationRequest, signatureSecret string) (*domain.VerificationResponse, error) {// 验证激活码}	return &ActivationService{db: db}func NewActivationService(db *gorm.DB) *ActivationService {}	db *gorm.DBtype ActivationService struct {